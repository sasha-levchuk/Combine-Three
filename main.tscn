[gd_scene load_steps=6 format=3 uid="uid://drjvpsepkhyqj"]

[ext_resource type="PackedScene" uid="uid://d08j3muldqfjd" path="res://tiles/green.tscn" id="1_0xm2m"]
[ext_resource type="PackedScene" uid="uid://bt1ni5uvii8y4" path="res://tiles/red.tscn" id="1_h2yge"]
[ext_resource type="PackedScene" uid="uid://b8n38l8cvydts" path="res://tiles/blue.tscn" id="3_h2yge"]
[ext_resource type="PackedScene" uid="uid://d06i66vxv1826" path="res://tiles/yellow.tscn" id="4_1bvp3"]

[sub_resource type="GDScript" id="GDScript_7dm0k"]
resource_name = "Grid"
script/source = "extends Node2D
const START: Vector2i = Vector2i(0,0)
const SIZE: Vector2i = Vector2i(8, 8)
@export var scenes: Array[PackedScene]

var tiles: Dictionary[Vector2i, Tile]
var dragged_tile: Tile
var where_from: Vector2i
var matches: Array[Vector2i]
var tiles_left_to_respawn: int
var deferred_queue: Array[Callable]
@onready var advance := %AdvanceButton
@onready var tilesize := Vector2(64,64)


func _ready():
	populate_grid()


func reset_grid():
	for coord in tiles:
		tiles[coord].queue_free()
	tiles.clear()
	populate_grid()


func populate_grid():
	for row in SIZE.y:
		for col in SIZE.x:
			var coord := Vector2i(col, row)
			var type : int
			while true:
				type = randi() % Tile.TYPES.size()
				if (find_matches(coord, type, Vector2i(-1, 0)).size() < 2 
				and find_matches(coord, type, Vector2i(0, -1)).size() < 2 ):
					break
			spawn_tile( coord, type )


func spawn_tile( coord: Vector2i, type := randi()%Tile.TYPES.size() ):
	var tile: Tile = scenes[type].instantiate()
	tile.position = Vector2(coord) * tilesize
	tile.drag_started.connect( _on_tile_drag_started )
	tile.drag_ended.connect( _on_tile_drag_ended )
	add_child(tile)
	tiles[coord] = tile


func _on_tile_drag_started( tile: Tile ):
	dragged_tile = tile
	where_from = Vector2i( tile.position / tilesize )
	prints('started dragging', tile, 'from', where_from)


func _on_tile_drag_ended(direction: Vector2i):
	var where_to := where_from + direction
	if not is_in_bounds( where_to ):
		dragged_tile.move(where_from)
		return 
	prints('ended dragging')
	await swap(where_from, where_to)
	matches.clear()
	find_matches_3_axes(where_to, direction)
	find_matches_3_axes(where_from, Vector2i.ZERO - direction)
	while matches:
		await get_tree().create_timer(0.2).timeout
		respawn()
		swipe_down()
		await get_tree().create_timer(0.2).timeout
		matches.clear()
		find_matches_on_board()
		if not matches:
			break
		var rebuilt: Array[Vector2i]
		for coord in matches:
			if tiles.has(coord):
				rebuilt.append(coord)
				tiles[coord].queue_free()
				tiles.erase(coord)
		matches = rebuilt


func find_matches_3_axes(coord: Vector2i, direction: Vector2i):
	var type := tiles[coord].type
	var matches_along := find_matches(coord, type, direction)
	var flipped := Vector2i(direction.y, direction.x)
	var matches_ortho := find_matches(coord, type, Vector2i.ZERO - flipped)
	matches_ortho.append_array( find_matches(coord, type, flipped) )
	var result: Array[Vector2i]
	if matches_along.size() > 1:
		result.append_array(matches_along)
	if matches_ortho.size() > 1:
		result.append_array(matches_ortho)
	if result:
		result.append(coord)
		matches.append_array(result)
		for c in result:
			tiles[c].queue_free()
			tiles.erase(c)


func find_matches(coord, type, offset) -> Array[Vector2i]:
	var result: Array[Vector2i]
	while true:
		coord += offset
		if tiles.has(coord) and tiles[coord].type==type:
			result.append(coord)
		else:
			return result
	return []


func swap( origin: Vector2i, destination: Vector2i ) -> Signal:
	tiles[origin] = tiles[destination].move(origin)
	tiles[destination] = dragged_tile.move(destination)
	return dragged_tile.animation_ended


func is_in_bounds(v: Vector2i) -> bool:
	return START.x<=v.x and v.x<SIZE.x and START.y<=v.y and v.y<SIZE.y


func find_matches_on_board():
	for coord in tiles:
		var type := tiles[coord].type
		var hor_matches := find_matches(coord, type, Vector2i(1, 0))
		hor_matches.append_array( find_matches(coord, type, Vector2i(-1, 0)))
		if hor_matches.size()>1:
			matches.append_array(hor_matches)
			matches.append(coord)
		var ver_matches := find_matches(coord, type, Vector2i(0,1))
		ver_matches.append_array( find_matches(coord, type, Vector2i(0, -1)))
		if ver_matches.size()>1:
			matches.append_array(ver_matches)
			matches.append(coord)


func swipe_down():
	print('swiping down')
	var rebuilt_tiles: Dictionary[Vector2i, Tile]
	for coord in tiles:
		var offset := Vector2i.ZERO
		var coord_below := coord + Vector2i(0, -1)
		while coord_below.y >= 0:
			if not tiles.has(coord_below):
				offset += Vector2i(0, -1)
				prints('found a hole under', coord)
			coord_below += Vector2i(0, -1)
		rebuilt_tiles[coord+offset] = tiles[coord].move(coord+offset)
		prints('swiping tile', coord, 'to', coord+offset)
	tiles = rebuilt_tiles
	print_state()


func respawn():
	for coord in matches:
		var y = SIZE.y
		while tiles.has( Vector2i(coord.x, y) ):
			y += 1
		spawn_tile( Vector2i(coord.x, y) )


func print_state():
	print(' ')
	print('grid state:')
	var s := ''
	for y in SIZE.y:
		for x in SIZE.x:
			var v := Vector2i(x,SIZE.y-y-1)
			if tiles.has(v):
				s += (Tile.TYPES.keys()[tiles[v].type]).left(1)
			else:
				s += '-'
		s += '\\n'
	print(s)
"

[node name="Main" type="Node2D"]

[node name="ButtonReset" type="Button" parent="."]
offset_left = 628.0
offset_top = 458.0
offset_right = 752.0
offset_bottom = 489.0
text = "reset"

[node name="ButtonPrintState" type="Button" parent="."]
visible = false
offset_left = 628.0
offset_top = 489.0
offset_right = 752.0
offset_bottom = 520.0
text = "print state"

[node name="ButtonMatch" type="Button" parent="."]
visible = false
offset_left = 662.0
offset_top = 71.0
offset_right = 786.0
offset_bottom = 102.0
text = "match"

[node name="ButtonSwipe" type="Button" parent="."]
visible = false
offset_left = 662.0
offset_top = 102.0
offset_right = 786.0
offset_bottom = 133.0
text = "swipe"

[node name="ButtonRespawn" type="Button" parent="."]
visible = false
offset_left = 662.0
offset_top = 133.0
offset_right = 786.0
offset_bottom = 164.0
text = "respawn"

[node name="Grid" type="Node2D" parent="."]
position = Vector2(0, 600)
scale = Vector2(1, -1)
script = SubResource("GDScript_7dm0k")
scenes = Array[PackedScene]([ExtResource("1_h2yge"), ExtResource("1_0xm2m"), ExtResource("3_h2yge"), ExtResource("4_1bvp3")])

[node name="AdvanceButton" type="Button" parent="."]
unique_name_in_owner = true
visible = false
offset_left = 628.0
offset_top = 520.0
offset_right = 752.0
offset_bottom = 551.0
text = "advance"

[connection signal="pressed" from="ButtonReset" to="Grid" method="reset_grid"]
[connection signal="pressed" from="ButtonPrintState" to="Grid" method="print_state"]
[connection signal="pressed" from="ButtonMatch" to="Grid" method="clear_matches"]
[connection signal="pressed" from="ButtonSwipe" to="Grid" method="swipe_down"]
[connection signal="pressed" from="ButtonRespawn" to="Grid" method="respawn"]
