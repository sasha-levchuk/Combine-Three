[gd_scene load_steps=6 format=3 uid="uid://drjvpsepkhyqj"]

[ext_resource type="PackedScene" uid="uid://d08j3muldqfjd" path="res://tiles/green.tscn" id="1_0xm2m"]
[ext_resource type="PackedScene" uid="uid://bt1ni5uvii8y4" path="res://tiles/red.tscn" id="1_h2yge"]
[ext_resource type="PackedScene" uid="uid://b8n38l8cvydts" path="res://tiles/blue.tscn" id="3_h2yge"]
[ext_resource type="PackedScene" uid="uid://d06i66vxv1826" path="res://tiles/yellow.tscn" id="4_1bvp3"]

[sub_resource type="GDScript" id="GDScript_7dm0k"]
resource_name = "Grid"
script/source = "extends Node2D
const START: Vector2i = Vector2i(0,0)
const SIZE: Vector2i = Vector2i(8, 8)
@export var scenes: Array[PackedScene]

var tiles: Dictionary[Vector2i, Tile]
var dragged_tile: Tile
var where_from: Vector2i
#var matches: Array[Vector2i]
var tiles_left_to_respawn: int
var deferred_queue: Array[Callable]
@onready var advance := %AdvanceButton
@onready var tilesize := Vector2(64,64)


func _ready():
	populate_grid()


func reset_grid():
	for coord in tiles:
		tiles[coord].queue_free()
	tiles.clear()
	populate_grid()


func populate_grid():
	for row in SIZE.y:
		for col in SIZE.x:
			var coord := Vector2i(col, row)
			var type : int
			while true:
				type = randi() % Tile.TYPES.size()
				if (find_matches(coord, type, Vector2i(-1, 0)).size() < 2 
				and find_matches(coord, type, Vector2i(0, -1)).size() < 2 ):
					break
			spawn_tile( coord, type )


func spawn_tile( coord: Vector2i, type := randi()%Tile.TYPES.size() )->Tile:
	var tile: Tile = scenes[type].instantiate()
	tile.position = Vector2(coord) * tilesize
	tile.drag_started.connect( _on_tile_drag_started )
	tile.drag_ended.connect( _on_tile_drag_ended )
	add_child(tile)
	tiles[coord] = tile
	return tile


func _on_tile_drag_started( tile: Tile ):
	dragged_tile = tile
	where_from = Vector2i( tile.position / tilesize )
	prints('started dragging', tile, 'from', where_from)


func _on_tile_drag_ended(direction: Vector2i):
	var where_to := where_from + direction
	if not is_in_bounds( where_to ):
		dragged_tile.move( where_from )
		return 
	await swap(where_from, where_to, dragged_tile)
	if tiles[where_from].type == tiles[where_to].type:
		swap(where_to, where_from, dragged_tile)
		return
	
	var holes: Array[Vector2i]
	for coord in [where_from, where_to]:
		direction = -direction
		var matches := find_matches_3_axes(coord, tiles[coord].type, direction)
		if matches:
			matches.append(coord)
			holes.append_array(matches)
			for coord2 in matches:
				erase(coord2)
	if not holes:
		swap(where_to, where_from, dragged_tile)
		return
	
	while holes:
		respawn_from_array(holes)
		await swipe_down(holes)
		holes = find_matches_on_board()


func freeze( coord: Vector2i ):
	prints('coord', coord, 'has been frozen')


func erase( coord: Vector2i ):
	tiles[coord].queue_free()
	tiles.erase(coord)


func find_matches_3_axes( coord: Vector2i,
		type: int, direction: Vector2i ) -> Array[ Vector2i ]:
	var result: Array[ Vector2i ]
	var matches_along := find_matches( coord, type, direction )
	if matches_along.size() >= 2:
		result.append_array( matches_along )
	var flipped := Vector2i( direction.y, direction.x )
	var matches_ortho := find_matches( coord, type, Vector2i.ZERO - flipped )
	matches_ortho.append_array( find_matches( coord, type, flipped ) )
	if matches_ortho.size() >= 2:
		result.append_array( matches_ortho )
	return result


func find_matches(coord, type, offset) -> Array[Vector2i]:
	var result: Array[Vector2i]
	while true:
		coord += offset
		if tiles.has(coord) and tiles[coord].type==type:
			result.append(coord)
		else:
			return result
	return []


func swap( origin: Vector2i, destination: Vector2i, spare := tiles[origin] ) -> Signal:
	tiles[origin] = tiles[destination].move(origin)
	tiles[destination] = spare.move(destination)
	return spare.animation_ended


func is_in_bounds(v: Vector2i) -> bool:
	return START.x<=v.x and v.x<SIZE.x and START.y<=v.y and v.y<SIZE.y


func find_matches_on_board() -> Array[Vector2i]:
	var matches: Array[Vector2i]
	for coord in tiles:
		var type := tiles[ coord ].type
		var hor_matches := find_matches( coord, type, Vector2i(1, 0))
		hor_matches.append_array( find_matches( coord, type, Vector2i(-1, 0)))
		if hor_matches.size()>1:
			matches.append_array( hor_matches )
			matches.append( coord )
		var ver_matches := find_matches( coord, type, Vector2i(0,1))
		ver_matches.append_array( find_matches( coord, type, Vector2i(0, -1)))
		if ver_matches.size()>1:
			matches.append_array( ver_matches )
			matches.append( coord )
	var rebuilt: Array[Vector2i]
	for coord in matches:
		if tiles.has(coord):
			erase(coord)
			rebuilt.append(coord)
	return rebuilt


func swipe_down(holes: Array[Vector2i]) -> Signal:
	var offsets: Dictionary[Vector2i, Vector2i]
	for coord in holes: # calculate offsets for all tiles
		while true:
			coord += Vector2i(0,1)
			if tiles.has(coord):
				offsets[coord] = offsets[coord]-Vector2i(0,1) if offsets.has(coord) else Vector2i(0,-1)
				freeze(coord)
			elif not is_in_bounds(coord):
				break
	
	var rebuilt_tiles: Dictionary[Vector2i, Tile]
	var board_was_rebuilt: Signal
	for coord in tiles:
		if offsets.has(coord):
			var new_coord := coord + offsets[coord]
			rebuilt_tiles[new_coord] = tiles[coord].move(new_coord)
			board_was_rebuilt = tiles[coord].animation_ended
		else:
			rebuilt_tiles[coord] = tiles[coord]
	tiles = rebuilt_tiles
	return board_was_rebuilt


func swipe_down2(matches: Array[Vector2i])->Signal:
	var has_been_swiped: Signal
	var holes: Array[ Vector2i ]
	var offsets: Dictionary[ Vector2i, Vector2i ]
	for coord in matches: #calculate offsets before a swipe down
		if tiles.has( coord ):
			holes.append( coord )
			tiles[coord].queue_free()
			tiles.erase( coord )
			while true:
				coord += Vector2i(0, 1)
				if not is_in_bounds( coord ):
					break
				offsets[coord] = offsets[coord] - Vector2i(0,1) if offsets.has(coord) else Vector2i(0,-1)
	var rebuilt_tiles: Dictionary[Vector2i, Tile]
	for coord in tiles:
		if offsets.has(coord):
			var offset := offsets[coord]
			rebuilt_tiles[coord+offset] = tiles[coord].move( coord + offset )
			has_been_swiped = rebuilt_tiles[coord+offset].animation_ended
		else:
			rebuilt_tiles[coord] = tiles[coord]
	tiles = rebuilt_tiles
	return has_been_swiped


func swipe_down_no_array()->Signal:
	var was_swept_down: Signal
	print('swiping down')
	var rebuilt_tiles: Dictionary[Vector2i, Tile]
	for coord in tiles:
		var offset := Vector2i.ZERO
		var coord_below := coord + Vector2i(0, -1)
		while coord_below.y >= 0:
			if not tiles.has(coord_below):
				offset += Vector2i(0, -1)
				prints('found a hole under', coord)
			coord_below += Vector2i(0, -1)
		rebuilt_tiles[coord+offset] = tiles[coord].move(coord+offset)
		was_swept_down = rebuilt_tiles[coord+offset].animation_ended
		prints('swiping tile', coord, 'to', coord+offset)
	tiles = rebuilt_tiles
	print_state()
	return was_swept_down


func respawn_from_array( coords: Array[ Vector2i ] ):
	for coord in coords:
		coord = Vector2i( coord.x, SIZE.y )
		while tiles.has(coord):
			coord += Vector2i(0,1)
		spawn_tile(coord)


func print_state():
	print(' ')
	print('grid state:')
	var s := ''
	for y in SIZE.y:
		for x in SIZE.x:
			var v := Vector2i(x,SIZE.y-y-1)
			if tiles.has(v):
				s += (Tile.TYPES.keys()[tiles[v].type]).left(1)
			else:
				s += '-'
		s += '\\n'
	print(s)
"

[node name="Main" type="Node2D"]

[node name="ButtonReset" type="Button" parent="."]
offset_left = 14.0
offset_top = 554.0
offset_right = 138.0
offset_bottom = 585.0
text = "reset"

[node name="ButtonPrintState" type="Button" parent="."]
visible = false
offset_left = 628.0
offset_top = 489.0
offset_right = 752.0
offset_bottom = 520.0
text = "print state"

[node name="ButtonMatch" type="Button" parent="."]
visible = false
offset_left = 662.0
offset_top = 71.0
offset_right = 786.0
offset_bottom = 102.0
text = "match"

[node name="ButtonSwipe" type="Button" parent="."]
visible = false
offset_left = 662.0
offset_top = 102.0
offset_right = 786.0
offset_bottom = 133.0
text = "swipe"

[node name="ButtonRespawn" type="Button" parent="."]
visible = false
offset_left = 662.0
offset_top = 133.0
offset_right = 786.0
offset_bottom = 164.0
text = "respawn"

[node name="Grid" type="Node2D" parent="."]
position = Vector2(0, 540)
scale = Vector2(1, -1)
script = SubResource("GDScript_7dm0k")
scenes = Array[PackedScene]([ExtResource("1_h2yge"), ExtResource("1_0xm2m"), ExtResource("3_h2yge"), ExtResource("4_1bvp3")])

[node name="AdvanceButton" type="Button" parent="."]
unique_name_in_owner = true
visible = false
offset_left = 628.0
offset_top = 520.0
offset_right = 752.0
offset_bottom = 551.0
text = "advance"

[connection signal="pressed" from="ButtonReset" to="Grid" method="reset_grid"]
[connection signal="pressed" from="ButtonPrintState" to="Grid" method="print_state"]
[connection signal="pressed" from="ButtonMatch" to="Grid" method="clear_matches"]
[connection signal="pressed" from="ButtonSwipe" to="Grid" method="swipe_down"]
[connection signal="pressed" from="ButtonRespawn" to="Grid" method="respawn"]
